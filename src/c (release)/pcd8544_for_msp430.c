#include "pcd8544_for_msp430.h"

// font map - used the Minecraft font :)
const unsigned char table[480] = { 0x00, 0x00, 0x00, 0x00, 0x00, // 20
		0x00, 0x00, 0x5f, 0x00, 0x00, // 21 !
		0x04, 0x03, 0x04, 0x03, 0x00, // 22 "
		0x14, 0x7f, 0x14, 0x7f, 0x14, // 23 #
		0x24, 0x2a, 0x6b, 0x2a, 0x12, // 24 $
		0x43, 0x30, 0x08, 0x06, 0x61, // 25 %
		0x30, 0x4a, 0x5d, 0x32, 0x48, // 26 &
		0x04, 0x03, 0x00, 0x00, 0x00, // 27 '
		0x1c, 0x22, 0x41, 0x41, 0x00, // 28 (
		0x41, 0x41, 0x22, 0x1c, 0x00, // 29 )
		0x14, 0x08, 0x08, 0x14, 0x00, // 2a *
		0x08, 0x08, 0x3e, 0x08, 0x08, // 2b +
		0x00, 0x00, 0xe0, 0x00, 0x00, // 2c ,
		0x08, 0x08, 0x08, 0x08, 0x08, // 2d -
		0x00, 0x00, 0x60, 0x00, 0x00, // 2e .
		0x40, 0x30, 0x08, 0x06, 0x01, // 2f /
		0x3e, 0x51, 0x49, 0x45, 0x3e, // 30 0
		0x40, 0x42, 0x7f, 0x40, 0x40, // 31 1
		0x62, 0x51, 0x49, 0x49, 0x66, // 32 2
		0x22, 0x41, 0x49, 0x49, 0x36, // 33 3
		0x18, 0x14, 0x12, 0x11, 0x7f, // 34 4
		0x27, 0x45, 0x45, 0x45, 0x39, // 35 5
		0x3c, 0x4a, 0x49, 0x49, 0x30, // 36 6
		0x03, 0x01, 0x71, 0x09, 0x07, // 37 7
		0x36, 0x49, 0x49, 0x49, 0x36, // 38 8
		0x06, 0x49, 0x49, 0x29, 0x1e, // 39 9
		0x00, 0x36, 0x36, 0x00, 0x00, // 3a :
		0x00, 0x56, 0x36, 0x00, 0x00, // 3b ;
		0x08, 0x14, 0x22, 0x41, 0x00, // 3c <
		0x14, 0x14, 0x14, 0x14, 0x14, // 3d =
		0x00, 0x41, 0x22, 0x14, 0x08, // 3e >
		0x02, 0x01, 0x51, 0x09, 0x06, // 3f ?
		0x3e, 0x41, 0x5d, 0x51, 0x1e, // 40 @
		0x7e, 0x05, 0x05, 0x05, 0x7e, // 41 A
		0x7f, 0x45, 0x45, 0x45, 0x3a, // 42 B
		0x3e, 0x41, 0x41, 0x41, 0x22, // 43 C
		0x7f, 0x41, 0x41, 0x41, 0x3e, // 44 D
		0x7f, 0x45, 0x45, 0x41, 0x41, // 45 E
		0x7f, 0x05, 0x05, 0x05, 0x01, // 46 F
		0x3e, 0x41, 0x41, 0x45, 0x3d, // 47 G
		0x7f, 0x04, 0x04, 0x04, 0x7f, // 48 H
		0x00, 0x41, 0x7f, 0x41, 0x00, // 49 I
		0x20, 0x40, 0x40, 0x40, 0x3f, // 4a J
		0x7f, 0x04, 0x04, 0x0a, 0x71, // 4b K
		0x7f, 0x40, 0x40, 0x40, 0x40, // 4c L
		0x7f, 0x02, 0x04, 0x02, 0x7f, // 4d M
		0x7f, 0x02, 0x04, 0x08, 0x7f, // 4e N
		0x3e, 0x41, 0x41, 0x41, 0x3e, // 4f O
		0x7f, 0x05, 0x05, 0x05, 0x02, // 50 P
		0x3e, 0x41, 0x51, 0x21, 0x5e, // 51 Q
		0x7f, 0x05, 0x05, 0x05, 0x7a, // 52 R
		0x22, 0x45, 0x45, 0x45, 0x39, // 53 S
		0x01, 0x01, 0x7f, 0x01, 0x01, // 54 T
		0x3f, 0x40, 0x40, 0x40, 0x3f, // 55 U
		0x0f, 0x30, 0x40, 0x30, 0x0f, // 56 V
		0x7f, 0x20, 0x10, 0x20, 0x7f, // 57 W
		0x71, 0x0a, 0x04, 0x0a, 0x71, // 58 X
		0x01, 0x02, 0x7c, 0x02, 0x01, // 59 Y
		0x61, 0x51, 0x49, 0x45, 0x43, // 5a Z
		0x00, 0x7f, 0x41, 0x41, 0x00, // 5b [
		0x00, 0x06, 0x08, 0x30, 0x40, // 5c (backslash)
		0x00, 0x41, 0x41, 0x7f, 0x00, // 5d ]
		0x04, 0x02, 0x01, 0x02, 0x04, // 5e ^
		0x40, 0x40, 0x40, 0x40, 0x40, // 5f _
		0x00, 0x03, 0x04, 0x00, 0x00, // 60 `
		0x20, 0x54, 0x54, 0x54, 0x78, // 61 a
		0x7f, 0x48, 0x44, 0x44, 0x38, // 62 b
		0x38, 0x44, 0x44, 0x44, 0x28, // 63 c
		0x38, 0x44, 0x44, 0x48, 0x7f, // 64 d
		0x38, 0x54, 0x54, 0x54, 0x58, // 65 e
		0x08, 0x7e, 0x09, 0x09, 0x00, // 66 f
		0x98, 0xa4, 0xa4, 0xa4, 0x7c, // 67 g
		0x7f, 0x08, 0x04, 0x04, 0x78, // 68 h
		0x00, 0x00, 0x7d, 0x00, 0x00, // 69 i
		0x60, 0x80, 0x80, 0x80, 0x7d, // 6a j
		0x7f, 0x10, 0x28, 0x44, 0x00, // 6b k
		0x00, 0x00, 0x3f, 0x40, 0x00, // 6c l
		0x7c, 0x04, 0x18, 0x04, 0x78, // 6d m
		0x7c, 0x04, 0x04, 0x04, 0x78, // 6e n
		0x38, 0x44, 0x44, 0x44, 0x38, // 6f o
		0xfc, 0x28, 0x24, 0x24, 0x18, // 70 p
		0x18, 0x24, 0x24, 0x28, 0xfc, // 71 q
		0x7c, 0x08, 0x04, 0x04, 0x08, // 72 r
		0x48, 0x54, 0x54, 0x54, 0x24, // 73 s
		0x00, 0x04, 0x3f, 0x44, 0x00, // 74 t
		0x3c, 0x40, 0x40, 0x40, 0x7c, // 75 u
		0x1c, 0x20, 0x40, 0x20, 0x1c, // 76 v
		0x3c, 0x40, 0x70, 0x40, 0x7c, // 77 w
		0x44, 0x28, 0x10, 0x28, 0x44, // 78 x
		0x9c, 0xa0, 0xa0, 0xa0, 0x7c, // 79 y
		0x44, 0x64, 0x54, 0x4c, 0x44, // 7a z
		0x08, 0x36, 0x41, 0x41, 0x00, // 7b {
		0x00, 0x00, 0x77, 0x00, 0x00, // 7c |
		0x00, 0x41, 0x41, 0x36, 0x08, // 7d }
		0x02, 0x01, 0x01, 0x02, 0x01, // 7e ~
		};

void wait(volatile unsigned int ms) {
	do
		ms--;
	while (ms != 0);
}

void nokia_init(void) {
	wait(10000);
	P1OUT = P1OUT | nok_dc; // set high
	wait(10000); //normal value 100
	P1OUT = P1OUT & ~nok_reset; // set low
	wait(10000); //normal value 100
	P1OUT = P1OUT | nok_reset; // set high
	nokia_send_cmd(0x21); // Setting LCD extended command mode
	nokia_send_cmd(0xB9); // Setting Vop contrast at 0xB9 for 3VDC
	nokia_send_cmd(0x13); // Sets LCD bias to 1:48
	nokia_send_cmd(0x20); // Set LCD to interpret display data left to right
	nokia_send_cmd(0x09); // Activate the display
	wait(1000); //normal value 100
	nokia_ddram_clear(); // Purge the DDRAM display buffer
	wait(1000); //normal value 100
	nokia_send_cmd(0x08); // Clears the screen
	wait(1000); //normal value 100
	nokia_send_cmd(0x0C); // Sets LCD normal mode
}

void nokia_ddram_clear(void) {
	int ddram;
	nokia_goto_cursor(0, 0); //writes 84*6 bit area (504 bits) with zero
	for (ddram = 0; ddram < 504; ddram++)
		nokia_write_data(0x00);
}

void nokia_send_cmd(char nokia_command) {
	P1OUT = P1OUT & ~nok_dc; // Sets the D/C pin to 0
	nokia_send_byte(nokia_command);
}

void nokia_write_data(char nokia_data) {
	P1OUT = P1OUT | nok_dc; // Sets the D/C pin to 1
	nokia_send_byte(nokia_data);
}

void nokia_send_byte(char byte_nokia) // Sends LCD byte data
{
	char i;
	for (i = 8; i > 0; i--) {
		P1OUT = P1OUT & ~nok_sclk;
		if ((byte_nokia & 0x80) == 0) {
			P1OUT = P1OUT & ~nok_sdin; // set bit low
		} else {
			P1OUT = P1OUT | nok_sdin; // set bit high
		}
		P1OUT = P1OUT | nok_sclk; // set bit high
		byte_nokia = byte_nokia << 1;
		wait(10);
	}
}

void nokia_goto_cursor(char xnokia, char ynokia) // Scrolls to cursor
{
	nokia_send_cmd(0x40 | (ynokia & 0x07)); // Moves Y cursor: 0100 0yyy
	nokia_send_cmd(0x80 | (xnokia & 0x7F)); // Moves X cursor: 1xxx xxxx
}

void nokia_contrast(char contrast) {
	nokia_send_cmd(0x21); // Sets LCD extended command
	nokia_send_cmd(0x80 | contrast); // Sets contrast
	nokia_send_cmd(0x20); // Sets horizontal addressing
}

void nokia_print_string(const char *s) {
	while (*s)
		nokia_print_char(*s++);
}

void nokia_print_char(char charsel) // Prints one character on screen
{
	char char_row, chardata;
	unsigned int charpos;

	if (charsel < 0x20)
		return;
	if (charsel > 0x7f)
		return;

	for (char_row = 0; char_row < 5; char_row++) {

		charpos = (charsel - 0x20) * 5;
		chardata = table[(charpos + char_row)];
		nokia_write_data(chardata); // Writes character data
	}
	nokia_write_data(0x00); // Sends 0x00
}

void lcdpixel(char x, char y) {
	char offset, data;

	if (x > 84)
		return;
	if (y > 48)
		return;

	offset = y - ((y / 8) * 8);
	data = (0x01 << offset);

	nokia_goto_cursor(x, (y / 6));
	nokia_write_data(data);
}

void draw_image(const unsigned char *img_ptr) {
	int i = 504;
	nokia_goto_cursor(0, 0);
	for(; i != 0; i--){
		nokia_write_data(*img_ptr++); // Writes character data
	}
}
